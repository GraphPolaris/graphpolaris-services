{
  "$schema": "https://schema.management.azure.com/schemas/2019-04-01/deploymentTemplate.json#",
  "contentVersion": "1.0.0.0",
  "parameters": {
    "clusterName": {
      "type": "string",
      "defaultValue": "[concat('aks-cluster-', uniqueString(resourceGroup().id))]",
      "metadata": {
        "description": "Name of the AKS cluster"
      }
    },
    "location": {
      "type": "string",
      "defaultValue": "[resourceGroup().location]",
      "metadata": {
        "description": "Location for all resources"
      }
    },
    "nodeCount": {
      "type": "int",
      "defaultValue": 3,
      "minValue": 3,
      "maxValue": 10,
      "metadata": {
        "description": "Number of nodes in the agent pool"
      }
    },
    "nodeVmSize": {
      "type": "string",
      "defaultValue": "Standard_B2s",
      "metadata": {
        "description": "Size of the VMs in the agent pool"
      }
    },
    "kubernetesVersion": {
      "type": "string",
      "defaultValue": "1.31",
      "metadata": {
        "description": "Kubernetes version"
      }
    },
    "dnsPrefix": {
      "type": "string",
      "defaultValue": "[concat('aks-', uniqueString(resourceGroup().id))]",
      "metadata": {
        "description": "DNS prefix for the AKS cluster"
      }
    },
    "servicePrincipalClientId": {
      "type": "string",
      "defaultValue": "",
      "metadata": {
        "description": "Service principal client ID (appId). If not provided, a managed identity will be used."
      }
    },
    "servicePrincipalClientSecret": {
      "type": "securestring",
      "defaultValue": "",
      "metadata": {
        "description": "Service principal client secret. Required if servicePrincipalClientId is provided."
      }
    },
    "helmRegistry": {
      "type": "string",
      "metadata": {
        "description": "Helm OCI registry URL"
      }
    },
    "helmRegistryUser": {
      "type": "string",
      "metadata": {
        "description": "Helm registry username"
      }
    },
    "helmRegistryPassword": {
      "type": "securestring",
      "metadata": {
        "description": "Helm registry password"
      }
    },
    "helmChartName": {
      "type": "string",
      "metadata": {
        "description": "Name of the Helm chart to install"
      }
    },
    "helmChartVersion": {
      "type": "string",
      "metadata": {
        "description": "Version of the Helm chart to install"
      }
    },
    "dockerConfigJson": {
      "type": "securestring",
      "metadata": {
        "description": "Base64 encoded docker config JSON for registry credentials"
      }
    },
    "admin_user": {
      "type": "string",
      "metadata": {
        "description": "Admin user for clientGateway service"
      }
    },
    "admin_password": {
      "type": "securestring",
      "metadata": {
        "description": "Admin password for clientGateway service"
      }
    }
  },
  "variables": {
    "useManagedIdentity": "[empty(parameters('servicePrincipalClientId'))]"
  },
  "resources": [
    {
      "type": "Microsoft.ContainerService/managedClusters",
      "apiVersion": "2023-11-01",
      "name": "[parameters('clusterName')]",
      "location": "[parameters('location')]",
      "identity": "[if(variables('useManagedIdentity'), createObject('type', 'SystemAssigned'), json('null'))]",
      "properties": {
        "kubernetesVersion": "[parameters('kubernetesVersion')]",
        "dnsPrefix": "[parameters('dnsPrefix')]",
        "agentPoolProfiles": [
          {
            "name": "agentpool",
            "count": "[parameters('nodeCount')]",
            "vmSize": "[parameters('nodeVmSize')]",
            "osType": "Linux",
            "mode": "System",
            "type": "VirtualMachineScaleSets",
            "enableAutoScaling": false
          }
        ],
        "servicePrincipalProfile": "[if(variables('useManagedIdentity'), json('null'), createObject('clientId', parameters('servicePrincipalClientId'), 'secret', parameters('servicePrincipalClientSecret')))]",
        "networkProfile": {
          "networkPlugin": "kubenet",
          "loadBalancerSku": "Standard",
          "loadBalancerProfile": {
            "managedOutboundIPs": {
              "count": 1
            }
          }
        },
        "addonProfiles": {
          "httpApplicationRouting": {
            "enabled": false
          }
        },
        "enableRBAC": true
      }
    },
    {
      "type": "Microsoft.Resources/deploymentScripts",
      "apiVersion": "2023-08-01",
      "name": "[concat('deploy-graphpolaris-services-', uniqueString(resourceGroup().id))]",
      "location": "[parameters('location')]",
      "kind": "AzureCLI",
      "dependsOn": [
        "[resourceId('Microsoft.ContainerService/managedClusters', parameters('clusterName'))]"
      ],
      "identity": {
        "type": "UserAssigned",
        "userAssignedIdentities": {
          "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', concat('id-', uniqueString(resourceGroup().id)))]": {}
        }
      },
      "properties": {
        "azCliVersion": "2.50.0",
        "timeout": "PT10M",
        "retentionInterval": "P1D",
        "environmentVariables": [
          {
            "name": "CLUSTER_NAME",
            "value": "[parameters('clusterName')]"
          },
          {
            "name": "RESOURCE_GROUP",
            "value": "[resourceGroup().name]"
          },
          {
            "name": "SUBSCRIPTION_ID",
            "value": "[subscription().subscriptionId]"
          },
          {
            "name": "HELM_REGISTRY",
            "value": "[parameters('helmRegistry')]"
          },
          {
            "name": "HELM_REGISTRY_USER",
            "value": "[parameters('helmRegistryUser')]"
          },
          {
            "name": "HELM_REGISTRY_PASSWORD",
            "value": "[parameters('helmRegistryPassword')]"
          },
          {
            "name": "HELM_CHART_NAME",
            "value": "[parameters('helmChartName')]"
          },
          {
            "name": "HELM_CHART_VERSION",
            "value": "[parameters('helmChartVersion')]"
          },
          {
            "name": "DOCKER_CONFIG_JSON",
            "value": "[parameters('dockerConfigJson')]"
          },
          {
            "name": "ADMIN_USER",
            "value": "[parameters('admin_user')]"
          },
          {
            "name": "ADMIN_PASSWORD",
            "value": "[parameters('admin_password')]"
          }
        ],
        "scriptContent": "#!\/bin\/bash\r\nset -e\r\n\r\n# Install required tools\r\nfor cmd in kubectl helm jq; do\r\n  if ! command -v $cmd &> \/dev\/null; then\r\n    case $cmd in\r\n      kubectl) az aks install-cli 2>\/dev\/null || (curl -LO \"https:\/\/dl.k8s.io\/release\/$(curl -L -s https:\/\/dl.k8s.io\/release\/stable.txt)\/bin\/linux\/amd64\/kubectl\" && chmod +x kubectl && sudo mv kubectl \/usr\/local\/bin\/ 2>\/dev\/null || mv kubectl \/usr\/local\/bin\/) ;;\r\n      helm) curl https:\/\/raw.githubusercontent.com\/helm\/helm\/main\/scripts\/get-helm-3 | bash ;;\r\n      jq) sudo apt-get update -qq && sudo apt-get install -y jq 2>\/dev\/null || (curl -L https:\/\/github.com\/jqlang\/jq\/releases\/download\/jq-1.7.1\/jq-linux-amd64 -o \/tmp\/jq && chmod +x \/tmp\/jq && sudo mv \/tmp\/jq \/usr\/local\/bin\/) ;;\r\n    esac\r\n  fi\r\ndone\r\n\r\n# Setup AKS access\r\naz account set --subscription $SUBSCRIPTION_ID\r\naz aks get-credentials --resource-group $RESOURCE_GROUP --name $CLUSTER_NAME --admin --overwrite-existing\r\nkubectl wait --for=condition=Ready nodes --all --timeout=300s || true\r\n\r\n# Install Helm chart\r\nexport HELM_EXPERIMENTAL_OCI=1\r\necho \"$HELM_REGISTRY_PASSWORD\" | helm registry login -u \"$HELM_REGISTRY_USER\" --password-stdin \"https:\/\/$HELM_REGISTRY\"\r\n\r\ncat > \/tmp\/helm-values.yaml <<EOF\r\nglobal:\r\n  registryCredentials:\r\n    dockerconfigjson: \"$DOCKER_CONFIG_JSON\"\r\nclientGateway:\r\n  env:\r\n    ADMIN_USER: \"$ADMIN_USER\"\r\n    ADMIN_PASSWORD: \"$ADMIN_PASSWORD\"\r\ndatabaseService:\r\n  env:\r\n    ADMIN_USER: \"$ADMIN_USER\"\r\n    ADMIN_PASSWORD: \"$ADMIN_PASSWORD\"\r\nEOF\r\n\r\necho \"Installing Helm chart...\"\r\nhelm upgrade --install graphpolaris-services \"oci:\/\/$HELM_REGISTRY\/graphpolaris-helm\/$HELM_CHART_NAME\" --version \"$HELM_CHART_VERSION\" -f \/tmp\/helm-values.yaml\r\necho \"Waiting for deployment to be available...\"\r\nkubectl wait --for=condition=available --timeout=600s deployment --all --all-namespaces || true\r\n\r\n# Wait for LoadBalancer IPs\r\nfor i in {1..30}; do\r\n  CLIENT_GATEWAY_IP=$(kubectl get svc client-gateway -n client-gateway -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>\/dev\/null || echo \"\")\r\n  [ -n \"$CLIENT_GATEWAY_IP\" ] && break\r\n  [ $i -lt 30 ] && sleep 10\r\ndone\r\n\r\n# Update frontend and graphImporter with LoadBalancer IP\r\nif [ -n \"$CLIENT_GATEWAY_IP\" ]; then\r\n  CLIENT_GATEWAY_PORT=$(kubectl get svc client-gateway -n client-gateway -o jsonpath='{.spec.ports[0].port}' 2>\/dev\/null || echo \"80\")\r\n  export BACKEND_URL=\"http:\/\/$CLIENT_GATEWAY_IP:$CLIENT_GATEWAY_PORT\"\r\n  \r\n  if command -v python3 &> \/dev\/null && python3 -c \"import yaml\" 2>\/dev\/null; then\r\n    helm get values graphpolaris-services -o yaml > \/tmp\/current-values.yaml 2>\/dev\/null || echo \"\" > \/tmp\/current-values.yaml\r\n    python3 <<PYEOF\r\nimport yaml, os\r\nvalues = yaml.safe_load(open('\/tmp\/current-values.yaml')) or {}\r\nvalues.setdefault('frontend', {}).setdefault('env', [])\r\nvalues.setdefault('graphImporter', {}).setdefault('env', {})\r\n\r\nbackend_url = os.environ.get('BACKEND_URL', '')\r\nenv_updates = {'BACKEND_URL': backend_url, 'BACKEND_AUTH': backend_url + '\/api\/auth', 'BACKEND_WSS_URL': backend_url.replace('http', 'ws') + '\/ws'}\r\nupdated = {e['name'] for e in values['frontend']['env'] if e.get('name') in env_updates}\r\nfor name, value in env_updates.items():\r\n  if name in updated:\r\n    next((e.update({'value': value}) for e in values['frontend']['env'] if e.get('name') == name), None)\r\n  else:\r\n    values['frontend']['env'].append({'name': name, 'value': value})\r\n\r\nvalues['graphImporter']['env']['SAVE_STATE_SERVICE_URL'] = backend_url\r\nvalues.update({'global': {'registryCredentials': {'dockerconfigjson': os.environ.get('DOCKER_CONFIG_JSON', '')}}, 'clientGateway': {'env': {'ADMIN_USER': os.environ.get('ADMIN_USER', ''), 'ADMIN_PASSWORD': os.environ.get('ADMIN_PASSWORD', '')}}, 'databaseService': {'env': {'ADMIN_USER': os.environ.get('ADMIN_USER', ''), 'ADMIN_PASSWORD': os.environ.get('ADMIN_PASSWORD', '')}}})\r\n\r\nyaml.dump(values, open('\/tmp\/helm-values-final.yaml', 'w'), default_flow_style=False)\r\nPYEOF\r\n    helm upgrade graphpolaris-services \"oci:\/\/$HELM_REGISTRY\/graphpolaris-helm\/$HELM_CHART_NAME\" --version \"$HELM_CHART_VERSION\" -f \/tmp\/helm-values-final.yaml\r\n  else\r\n    kubectl set env deployment\/$(kubectl get deployment -n frontend -o jsonpath='{.items[0].metadata.name}') -n frontend BACKEND_URL=\"$BACKEND_URL\" BACKEND_AUTH=\"$BACKEND_URL\/api\/auth\" BACKEND_WSS_URL=\"ws:\/\/$CLIENT_GATEWAY_IP:$CLIENT_GATEWAY_PORT\/ws\" 2>\/dev\/null || true\r\n    kubectl set env deployment\/$(kubectl get deployment -n graph-importer -o jsonpath='{.items[0].metadata.name}') -n graph-importer SAVE_STATE_SERVICE_URL=\"$BACKEND_URL\" 2>\/dev\/null || true\r\n  fi\r\nfi\r\n\r\n# Run database migrations\r\nif kubectl get namespace client-gateway &>\/dev\/null; then\r\n  kubectl wait --for=condition=ready pod -l app.kubernetes.io\/name=client-gateway -n client-gateway --timeout=120s || true\r\n  CLIENT_GATEWAY_POD=$(kubectl get pod -n client-gateway -l app.kubernetes.io\/name=client-gateway -o jsonpath='{.items[0].metadata.name}' 2>\/dev\/null || echo \"\")\r\n  \r\n  if [ -n \"$CLIENT_GATEWAY_POD\" ]; then\r\n    # Check postgres readiness\r\n    for ns in client-gateway postgres-common; do\r\n      if kubectl get postgresql postgres-common -n $ns &>\/dev\/null; then\r\n        kubectl wait --for=condition=ready pod -l application=spilo -n $ns --timeout=300s 2>\/dev\/null && break\r\n      fi\r\n    done\r\n    \r\n    kubectl exec -n client-gateway $CLIENT_GATEWAY_POD -- bun db:migrate\r\n  fi\r\nfi\r\n\r\n# Collect all LoadBalancer service IPs and ports\r\necho \"Collecting LoadBalancer service information...\"\r\nkubectl get svc --all-namespaces -o json | jq '{services: [.items[] | select(.spec.type==\"LoadBalancer\") | {address: ((.status.loadBalancer.ingress[0].ip \/\/ \"Pending\") + \":\" + ((.spec.ports[0].port \/\/ \"N\/A\") | tostring))}]}' > \/tmp\/loadbalancer-services.json\r\n\r\n# Output to deployment script output path\r\nif [ -n \"$AZ_SCRIPTS_OUTPUT_PATH\" ]; then\r\n  cat \/tmp\/loadbalancer-services.json > \"$AZ_SCRIPTS_OUTPUT_PATH\"\r\nfi\r\n\r\necho \"\\n=== LoadBalancer Services ===\"\r\ncat \/tmp\/loadbalancer-services.json | jq -r '.services[].address' || cat \/tmp\/loadbalancer-services.json"
      }
    },
    {
      "type": "Microsoft.ManagedIdentity/userAssignedIdentities",
      "apiVersion": "2023-01-31",
      "name": "[concat('id-', uniqueString(resourceGroup().id))]",
      "location": "[parameters('location')]"
    },
    {
      "type": "Microsoft.Authorization/roleAssignments",
      "apiVersion": "2022-04-01",
      "name": "[guid(resourceGroup().id, 'aks-deployment-script-rg-contributor')]",
      "dependsOn": [
        "[resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', concat('id-', uniqueString(resourceGroup().id)))]"
      ],
      "properties": {
        "roleDefinitionId": "[subscriptionResourceId('Microsoft.Authorization/roleDefinitions', 'b24988ac-6180-42a0-ab88-20f7382dd24c')]",
        "principalId": "[reference(resourceId('Microsoft.ManagedIdentity/userAssignedIdentities', concat('id-', uniqueString(resourceGroup().id)))).principalId]",
        "principalType": "ServicePrincipal",
        "scope": "[resourceGroup().id]"
      }
    }
  ],
  "outputs": {
    "clusterName": {
      "type": "string",
      "value": "[parameters('clusterName')]"
    },
    "resourceGroup": {
      "type": "string",
      "value": "[resourceGroup().name]"
    },
    "kubeConfigCommand": {
      "type": "string",
      "value": "[concat('az aks get-credentials --resource-group ', resourceGroup().name, ' --name ', parameters('clusterName'))]"
    },
    "loadBalancerServices": {
      "type": "array",
      "value": "[json(reference(resourceId('Microsoft.Resources/deploymentScripts', concat('deploy-graphpolaris-services-', uniqueString(resourceGroup().id)))).outputs.result).services]"
    },
    "loadBalancerServicesJson": {
      "type": "string",
      "value": "[reference(resourceId('Microsoft.Resources/deploymentScripts', concat('deploy-graphpolaris-services-', uniqueString(resourceGroup().id)))).outputs.result]"
    }
  }
}